[{"content":"Barzin is a software that I developed in C++ using the Qt library. I aimed to create a modern general inventory management system. For this reason, in parallel with the core capabilities, say adding products with different attributes or registering customers\u0026rsquo; orders, I tried to add some features to this software to make it distinctive from its common counterparts; feature like \u0026ldquo;Dark Mode\u0026rdquo; is one of my favorites among these features that I rarely see in common software in this area.\nBased on this vision, I didn\u0026rsquo;t try to create a super application that satisfies all your needs from managing your stash to organizing your checks. So Barzin is a more general one which indeed may let you down if you have some special needs; but on the other hand, if the core features could be enough for you, it would give you a suite of nice functionalities.\nIt\u0026rsquo;s a fast and robust piece of software. By \u0026ldquo;robust\u0026rdquo;, I mean you never need to worry about if your changes on the system or your data would be lost at any stage of your work you are. I focused on getting rid of any cumbersome load of work that you may have to do, from adding any shape of data to removing them. You can easily find your data through the vast major database that holds lots of data. You can manage the \u0026ldquo;Units\u0026rdquo; that you use for products so that you don\u0026rsquo;t need to enter them all the time (regardless of the danger of redundant units) or you don\u0026rsquo;t need to search through an overwhelming list of units. In Barzin, you can easily manage your customers as well. You can select your old customer when you need instead of entering their name every time. It is also flexible in case of different types of products that you may want to add to your database (some may have expiration dates and some don\u0026rsquo;t for example). In the options, you would have a large number of items for configuring the software and fine-tuning different aspects of it.\nFeatures on the way: Online chat service for contacting the support team Export feature for the invoices in the PDF Supporting Persian language besides English ","permalink":"http://localhost:1313/posts/barzin-inventory-management-system/","summary":"Barzin is a software that I developed in C++ using the Qt library. I aimed to create a modern general inventory management system. For this reason, in parallel with the core capabilities, say adding products with different attributes or registering customers\u0026rsquo; orders, I tried to add some features to this software to make it distinctive from its common counterparts; feature like \u0026ldquo;Dark Mode\u0026rdquo; is one of my favorites among these features that I rarely see in common software in this area.","title":"Barzin Inventory Management System"},{"content":"This is a renderer that I have developed for the bachelor\u0026rsquo;s degree project. In the beginning, I used the Blinn-Phong rendering model for it and now I am working on implementing a physically-based rendering model. For controlling the objects in the scene from light sources to complicated mesh objects and for the sake of debugging, I also implemented a GUI using Dear ImGui.\nHere you can load meshes to the scene through GUI that under the hood uses the Assimp library and besides that, you can control each object\u0026rsquo;s attributes. There is a scene graph that controls all objects on the scene and in addition to these, you can add and configure different sources of light on the scene. Unfortunately, the shaders are hard-coded for now, but I plan to take care of that too in the future. Below the GUI there is a log widget that shows warnings errors and all other sorts of messages that you may need.\nThe core of the renderer is implemented via C++ and OpenGL. I implemented many basic techniques in this renderer and also some advanced techniques (such as deferred shading or SSAO) that make Anahita a more slick renderer. I will update this post whenever I will take this piece of software to another level.\nFuture Plans Implementing physically-based rendering model Developing a versatile world-editor Flexible editor for writing and changing shaders for each object Adding other types of source light ","permalink":"http://localhost:1313/posts/anahita-render-engine/","summary":"This is a renderer that I have developed for the bachelor\u0026rsquo;s degree project. In the beginning, I used the Blinn-Phong rendering model for it and now I am working on implementing a physically-based rendering model. For controlling the objects in the scene from light sources to complicated mesh objects and for the sake of debugging, I also implemented a GUI using Dear ImGui.\nHere you can load meshes to the scene through GUI that under the hood uses the Assimp library and besides that, you can control each object\u0026rsquo;s attributes.","title":"Anahita Render Engine"},{"content":"This is a simple clone of old famous game Legend of Zelda that I have created with my own 2D game engine. I created an ECS 2D game engine using C++ and SFML (as a library for handling graphics and sound). Due to this software architecture, it is easy to create new levels in a script file and then use that file in the game as a level. I didn\u0026rsquo;t pick any specific scripting language for this and it has a simple format for now. But as one of my goals in this project, I want to adopt Lua language for handling scripts as it gets more complicated.\nAs I said for now it is using SFML as a graphics library and I have plan to drop it out and replace it with my own graphics framework that deals with graphics (the same thing for the sound system). For debuging and also for in-game menus I used Dear ImGui. Eventhough, I can handle the menus via SFML, due to my plan for using OpenGL as the graphics library, I chose to use Dear ImGui cause it is a exhausting work to implement menus and dealing with texts in this library. In this specific game, I have implemented the backpack (inventory) in the Dear ImGui as well.\nFuture works Soon I will replace this clone with my own game which is still under development and as I said above I am going to implement abilities of the library that I am currently using with my own version.\n","permalink":"http://localhost:1313/posts/my-clone-of-retro-zelda-in-my-2d-game-engine/","summary":"This is a simple clone of old famous game Legend of Zelda that I have created with my own 2D game engine. I created an ECS 2D game engine using C++ and SFML (as a library for handling graphics and sound). Due to this software architecture, it is easy to create new levels in a script file and then use that file in the game as a level. I didn\u0026rsquo;t pick any specific scripting language for this and it has a simple format for now.","title":"My Clone of Retro Zelda in My 2D Game Engine"}]