[{"content":"Gandom is a software rasterizer that mimics algorithms which are behind graphics APIs and even what are implemented physically on GPU dies. In this project, I have implemented the processes used by graphics APIs and GPUs to render and synthesize an image for display, implemented entirely in code running on a CPU. For the performance issues I leveraged SIMD instructions (AVX2) to improve its performance. I implemented key algorithms of the graphics pipeline, such as triangle clipping, back-face culling, and scanline rasterization.\nKey Features Geometric Processing: Model/View/Projection transformations, perspective correct interpolation. Rasterization Core: Efficient triangle setup, scanline or barycentric-based pixel traversal. Per-Fragment Operations: Depth buffering (Z-buffering) for correct occlusion. Texture Mapping: Affine or perspective-correct texture sampling. Model Loading: Ability to parse and render standard 3D model file formats. Here are some images from Gandom:\nFuture Works Vertex and Fragment Shaders: Support for a simple shader model, allowing for programmable lighting and coloring. Texture Filtering: various filtering options like nearest-neighbor, bilinear, etc. Other Per-Fragment Operations: configurable blending modes. ","permalink":"http://localhost:1313/posts/gandom-rasterizer/","summary":"\u003cp\u003eGandom is a software rasterizer that mimics algorithms which are behind graphics APIs and even what are implemented physically on GPU dies.\nIn this project, I have implemented the processes used by graphics APIs\nand GPUs to render and synthesize an image for display,\nimplemented entirely in code running on a CPU. For the performance issues\nI leveraged SIMD instructions (AVX2) to improve its performance.\nI implemented key algorithms of the graphics pipeline,\nsuch as triangle clipping, back-face culling, and scanline rasterization.\u003c/p\u003e","title":"Gandom Rasterizer"},{"content":"Noora is a ray tracer began as a deep dive into the algorithms that bring virtual scenes to life. Starting with Peter Shirley\u0026rsquo;s accessible guides, I built a functional Monte Carlo path tracer—an offline renderer that simulates complex lighting effects like caustics and diffuse inter-reflection by tracing the path of light through a scene.\nCurrently, it is an offline renderer capable of producing images with global illumination, soft shadows, and realistic materials, but I am developing a GPU-accelerated, real-time version to explore the performance and algorithmic trade-offs between offline and interactive rendering.\nKey Features Core Features: Accurate global illumination, anti-aliasing, depth-of-field, and support for various geometric primitives.\nMaterial Model: Diffuse, metallic, and dielectric (glass) surfaces with configurable roughness.\nAcceleration: A bounding volume hierarchy (BVH) for significantly faster ray-intersection tests.\nFuture Works A Formal Monte Carlo Integration Framework Importance Sampling with Probability Density Functions (PDFs) Direct and Explicit Light Source Sampling Advanced PDF Management for Path Weights Orthonormal Basis (ONB) Generation for Sampling Implementing a True Scattering PDF for Materials Cosine-Weighted Sampling for Diffuse Surfaces Mixture Densities for Combined BRDF \u0026amp; Light Sampling Rendering Equation Mathematical Foundation Production-Ready Unbiased Path Tracer Architecture Change its backend to support CUDA, OpenGL or Vulkan. ","permalink":"http://localhost:1313/posts/noora-ray-tracer/","summary":"\u003cp\u003eNoora is a ray tracer began as a deep dive into the algorithms that bring virtual scenes to life. Starting with Peter Shirley\u0026rsquo;s accessible guides, I built a functional Monte Carlo path tracer—an offline renderer that simulates complex lighting effects like caustics and diffuse inter-reflection by tracing the path of light through a scene.\u003c/p\u003e\n\u003cp\u003eCurrently, it is an offline renderer capable of producing images with global illumination, soft shadows, and realistic materials, but I am developing a GPU-accelerated, real-time version to explore the performance and algorithmic trade-offs between offline and interactive rendering.\u003c/p\u003e","title":"Noora Ray Tracer"},{"content":"This is a renderer that I have developed for the bachelor\u0026rsquo;s degree project. In the beginning, I used the Blinn-Phong rendering model for it and now I am working on implementing a physically-based rendering model. For controlling the objects in the scene from light sources to complicated mesh objects and for the sake of debugging, I also implemented a GUI using Dear ImGui.\nHere you can load meshes to the scene through GUI that under the hood uses the Assimp library and besides that, you can control each object\u0026rsquo;s attributes. There is a scene graph that controls all objects on the scene and in addition to these, you can add and configure different sources of light on the scene. Unfortunately, the shaders are hard-coded for now, but I plan to take care of that too in the future. Below the GUI there is a log widget that shows warnings errors and all other sorts of messages that you may need.\nThe core of the renderer is implemented via C++ and OpenGL. I implemented many basic techniques in this renderer and also some advanced techniques (such as deferred shading or SSAO) that make Anahita a more slick renderer. I will update this post whenever I will take this piece of software to another level.\nFuture Plans Implementing physically-based rendering model Developing a versatile world-editor Flexible editor for writing and changing shaders for each object Adding other types of source light ","permalink":"http://localhost:1313/posts/anahita-render-engine/","summary":"\u003cp\u003eThis is a renderer that I have developed for the bachelor\u0026rsquo;s degree project. In the beginning, I used the Blinn-Phong rendering model for it and now I am working on implementing a physically-based rendering model. For controlling the objects in the scene from light sources to complicated mesh objects and for the sake of debugging, I also implemented a GUI using Dear ImGui.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"View\" loading=\"lazy\" src=\"/images/anahita/anahita-gui.png\"\u003e\u003c/p\u003e\n\u003cp\u003eHere you can load meshes to the scene through GUI that under the hood uses the Assimp library and besides that, you can control each object\u0026rsquo;s attributes. There is a scene graph that controls all objects on the scene and in addition to these, you can add and configure different sources of light on the scene. Unfortunately, the shaders are hard-coded for now, but I plan to take care of that too in the future. Below the GUI there is a log widget that shows warnings errors and all other sorts of messages that you may need.\u003c/p\u003e","title":"Anahita Render Engine"},{"content":"This is a simple clone of the old famous game Legend of Zelda that I have created with my 2D game engine. I created an ECS 2D game engine using C++ and SFML (as a library for handling graphics and sound). Due to this software architecture, it is easy to create new levels in a script file and then use that file in the game as a level. I didn\u0026rsquo;t pick any specific scripting language for this and it has a simple format for now. But as one of my goals in this project, I want to adopt the Lua language for handling scripts as it gets more complicated.\nAs I said for now it is using SFML as a graphics library and I plan to drop it out and replace it with my own graphics framework that deals with graphics (the same thing for the sound system). For debugging and also for in-game menus I used Dear ImGui. Even though I can handle the menus via SFML, due to my plan for using OpenGL as the graphics library, I chose to use Dear ImGui cause it is exhausting work to implement menus and deal with texts in this library. In this specific game, I have implemented the backpack (inventory) in the Dear ImGui as well.\nFuture works Soon I will replace this clone with my own game which is still under development and as I said above I am going to implement the abilities of the library that I am currently using with my version.\n","permalink":"http://localhost:1313/posts/retro-zelda-clone-in-my-own-2d-game-engine/","summary":"\u003cp\u003eThis is a simple clone of the old famous game Legend of Zelda that I have created with my 2D game engine. I created an ECS 2D game engine using C++ and SFML (as a library for handling graphics and sound). Due to this software architecture, it is easy to create new levels in a script file and then use that file in the game as a level. I didn\u0026rsquo;t pick any specific scripting language for this and it has a simple format for now. But as one of my goals in this project, I want to adopt the Lua language for handling scripts as it gets more complicated.\u003c/p\u003e","title":"Retro Zelda Clone in My Own 2D Game Engine"},{"content":"This is a software that I developed in C++ using the Qt library. I aimed to create a modern general inventory management system. For this reason, in parallel with the core capabilities, say adding products with different attributes or registering customers\u0026rsquo; orders, I tried to add some features to this software to make it distinctive from its common counterparts; feature like \u0026ldquo;Dark Mode\u0026rdquo; is one of my favorites among these features that I rarely see in common software in this area.\nBased on this vision, I didn\u0026rsquo;t try to create a super application that satisfies all your needs from managing your stash to organizing your checks. So Barzin is a more general one which indeed may let you down if you have some special needs; but on the other hand, if the core features could be enough for you, it would give you a suite of nice functionalities.\nIt\u0026rsquo;s a fast and robust piece of software. By \u0026ldquo;robust,\u0026rdquo; I mean you never need to worry about if your changes on the system or your data would be lost at any stage of your work you are. I focused on getting rid of any cumbersome load of work that you may have to do, from adding any shape of data to removing them. You can easily find your data through the vast major database that holds lots of data. You can manage the \u0026ldquo;Units\u0026rdquo; that you use for products so that you don\u0026rsquo;t need to enter them all the time (regardless of the danger of redundant units) or you don\u0026rsquo;t need to search through an overwhelming list of units. In this software you can easily manage your customers as well. You can select your old customer when you need instead of entering their name every time. It is also flexible in case of different types of products that you may want to add to your database (some may have expiration dates and some don\u0026rsquo;t for example). In the options, you would have a large number of items for configuring the software and fine-tuning different aspects of it.\nFeatures on the way: Online chat service for contacting the support team Export feature for the invoices in the PDF Supporting Persian language besides English ","permalink":"http://localhost:1313/posts/inventory-management-system/","summary":"\u003cp\u003eThis is a software that I developed in C++ using the Qt library. I aimed to create a modern general inventory management system.\nFor this reason, in parallel with the core capabilities, say adding products with different attributes or registering customers\u0026rsquo; orders,\nI tried to add some features to this software to make it distinctive from its common counterparts; feature like \u0026ldquo;Dark Mode\u0026rdquo; is one of my\nfavorites among these features that I rarely see in common software in this area.\u003c/p\u003e","title":"Inventory Management System Software"}]